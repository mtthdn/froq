#!/usr/bin/env python3
"""
Normalizer: UniProt REST API -> model/uniprot.cue

Queries the UniProt REST API for each gene's protein data using its UniProt
accession. Extracts protein name, organism, sequence length, subcellular
locations, and function descriptions.

Source-owned fields:
  - _in_uniprot: true
  - uniprot_id: UniProt accession
  - protein_name: recommended full name
  - organism: scientific name
  - sequence_length: amino acid count
  - subcellular_locations: [string, ...]
  - functions: [string, ...]
"""

import os
import sys
import time
import requests

# Resolve import path for sibling module
sys.path.insert(0, os.path.dirname(__file__))
from genes import GENES

UNIPROT_URL = "https://rest.uniprot.org/uniprotkb/{accession}?format=json"
SLEEP_SEC = 0.5

OUTPUT_PATH = os.path.join(os.path.dirname(__file__), "..", "model", "uniprot.cue")


def fetch_protein(accession: str) -> dict | None:
    """Fetch protein entry from UniProt REST API."""
    url = UNIPROT_URL.format(accession=accession)
    headers = {"Accept": "application/json"}
    try:
        resp = requests.get(url, headers=headers, timeout=30)
        resp.raise_for_status()
        return resp.json()
    except requests.RequestException as e:
        print(f"  WARNING: API error for {accession}: {e}", file=sys.stderr)
        return None


def extract_protein_name(data: dict) -> str:
    """Extract recommended full protein name."""
    try:
        return data["proteinDescription"]["recommendedName"]["fullName"]["value"]
    except (KeyError, TypeError):
        # Fall back to submissionNames or alternativeNames
        try:
            return data["proteinDescription"]["submissionNames"][0]["fullName"]["value"]
        except (KeyError, TypeError, IndexError):
            return ""


def extract_organism(data: dict) -> str:
    """Extract organism scientific name."""
    try:
        return data["organism"]["scientificName"]
    except (KeyError, TypeError):
        return ""


def extract_sequence_length(data: dict) -> int:
    """Extract protein sequence length."""
    try:
        return data["sequence"]["length"]
    except (KeyError, TypeError):
        return 0


def extract_subcellular_locations(data: dict) -> list[str]:
    """Extract subcellular location names from SUBCELLULAR LOCATION comments."""
    locations = []
    seen = set()
    for comment in data.get("comments", []):
        if comment.get("commentType") != "SUBCELLULAR LOCATION":
            continue
        for sub_loc in comment.get("subcellularLocations", []):
            loc = sub_loc.get("location", {})
            name = loc.get("value", "")
            if name and name not in seen:
                seen.add(name)
                locations.append(name)
    return locations


def extract_functions(data: dict) -> list[str]:
    """Extract function descriptions from FUNCTION comments."""
    functions = []
    for comment in data.get("comments", []):
        if comment.get("commentType") != "FUNCTION":
            continue
        for text_entry in comment.get("texts", []):
            value = text_entry.get("value", "")
            if value:
                functions.append(value)
    return functions


def escape_cue_string(s: str) -> str:
    """Escape a string for CUE literal embedding."""
    return s.replace("\\", "\\\\").replace('"', '\\"')


def format_cue(gene_data: dict[str, dict]) -> str:
    """Format the collected gene data as a CUE file."""
    lines = [
        "package lacuene",
        "",
        "// UniProt protein data from UniProt REST API.",
        "// Auto-generated by normalizers/from_uniprot.py â€” do not hand-edit.",
        "",
    ]

    for symbol in sorted(gene_data.keys()):
        entry = gene_data[symbol]
        lines.append(f'genes: "{symbol}": {{')
        lines.append(f"\t_in_uniprot: true")
        lines.append(f'\tuniprot_id:  "{escape_cue_string(entry["uniprot_id"])}"')

        if entry["protein_name"]:
            lines.append(
                f'\tprotein_name: "{escape_cue_string(entry["protein_name"])}"'
            )

        if entry["organism"]:
            lines.append(f'\torganism: "{escape_cue_string(entry["organism"])}"')

        if entry["sequence_length"]:
            lines.append(f'\tsequence_length: {entry["sequence_length"]}')

        locs = entry["subcellular_locations"]
        if locs:
            loc_items = ", ".join(f'"{escape_cue_string(l)}"' for l in locs)
            lines.append(f"\tsubcellular_locations: [{loc_items}]")

        funcs = entry["functions"]
        if funcs:
            if len(funcs) == 1 and len(funcs[0]) < 100:
                lines.append(
                    f'\tfunctions: ["{escape_cue_string(funcs[0])}"]'
                )
            else:
                lines.append("\tfunctions: [")
                for fn in funcs:
                    lines.append(f'\t\t"{escape_cue_string(fn)}",')
                lines.append("\t]")

        lines.append("}")
        lines.append("")

    return "\n".join(lines)


def main():
    print(f"from_uniprot: querying UniProt REST API for {len(GENES)} genes...")
    gene_data = {}

    for i, (symbol, ids) in enumerate(sorted(GENES.items()), 1):
        accession = ids["uniprot"]
        print(f"  [{i:2d}/{len(GENES)}] {symbol} ({accession})...", end=" ", flush=True)

        data = fetch_protein(accession)
        if data is None:
            print("SKIPPED (API error)")
            continue

        protein_name = extract_protein_name(data)
        organism = extract_organism(data)
        seq_length = extract_sequence_length(data)
        sub_locs = extract_subcellular_locations(data)
        funcs = extract_functions(data)

        gene_data[symbol] = {
            "uniprot_id": accession,
            "protein_name": protein_name,
            "organism": organism,
            "sequence_length": seq_length,
            "subcellular_locations": sub_locs,
            "functions": funcs,
        }
        print(f"OK ({seq_length} aa, {len(sub_locs)} locs, {len(funcs)} funcs)")

        if i < len(GENES):
            time.sleep(SLEEP_SEC)

    # Write CUE output
    cue_content = format_cue(gene_data)
    output = os.path.normpath(OUTPUT_PATH)
    os.makedirs(os.path.dirname(output), exist_ok=True)
    with open(output, "w") as f:
        f.write(cue_content)

    print(
        f"\nWrote {output} ({len(gene_data)} genes)"
    )


if __name__ == "__main__":
    main()
